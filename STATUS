Optimisation progress for libzahl, compared to other big integer
libraries. These comparisons are for 152-bit integers. Functions
in parenthesis the right column are functions that needs
optimisation to improve the peformance of the function in the
left column. Double-parenthesis means there may be a better way
to do it.

zset .................... fastest
zseti ................... tomsfastmath is faster
zsetu ................... tomsfastmath is faster
zneg(a, b) .............. fastest
zneg(a, a) .............. fastest (shared with gmp)
zabs(a, b) .............. fastest
zabs(a, a) .............. tomsfastmath is faster
zadd_unsigned ........... fastest (faster than all others' zadd)
zsub_unsigned ........... fastest (faster than all others' zsub)
zadd .................... 94 % of tomsfastmath, 90 % libtommath, 86 % of hebimath
zsub .................... 97 % of tomsfastmath, 95 % hebimath, 93 % of libtommath
zand .................... 55 % of tomsfastmath
zor ..................... 46 % of tomsfastmath
zxor .................... 57 % of tomsfastmath
znot .................... fastest
zeven ................... fastest (shared with gmp, libtommath, and tomsfastmath)
zodd .................... fastest (shared with gmp, libtommath, and tomsfastmath)
zeven_nonzero ........... fastest (shared with gmp, libtommath, and tomsfastmath)
zodd_nonzero ............ fastest (shared with gmp, libtommath, and tomsfastmath)
zzero ................... fastest (shared with gmp and libtommath)
zsignum ................. fastest (shared with gmp)
zbits ................... fastest
zlsb .................... fastest
zswap ................... fastest
zlsh .................... fastest
zrsh .................... fastest
ztrunc(a, b, c) ......... fastest
ztrunc(a, a, b) ......... fastest
zsplit .................. fastest
zcmpmag ................. fastest
zcmp .................... fastest
zcmpi ................... fastest
zcmpu ................... fastest
zbset(a, b, 1) .......... fastest
zbset(a, a, 1) .......... fastest
zbset(a, b, 0) .......... fastest
zbset(a, a, 0) .......... fastest
zbset(a, b, -1) ......... fastest
zbset(a, a, -1) ......... fastest
zbtest .................. fastest
zgcd .................... 21 % of gmp (zcmpmag)
zmul .................... slowest
zsqr .................... slowest (zmul)
zmodmul(big mod) ........ slowest ((zmul, zmod))
zmodsqr(big mod) ........ slowest ((zmul, zmod))
zmodmul(tiny mod) ....... slowest ((zmul))
zmodsqr(tiny mod) ....... slowest ((zmul))
zpow .................... slowest (zmul, zsqr)
zpowu ................... slowest (zmul, zsqr)
zmodpow ................. slowest (zmul, zsqr. zmod)
zmodpowu ................ slowest (zmul, zsqr, zmod)
zsets ................... 13 % of gmp
zstr_length(a, 10) ...... gmp is faster (zdiv, zsqr)
zstr(a, b, n) ........... 8 % of gmp, 59 % of hebimath
zrand(default uniform) .. 51 % of gmp
zptest .................. slowest (zrand, zmodpow, zsqr, zmod)
zsave ................... fastest
zload ................... fastest
zdiv(big denum) ......... tomsfastmath and na√Øve hebimath implementation are faster (zdivmod)
zmod(big denum) ......... fastest (zdivmod)
zdivmod(big denum) ...... fastest
zdiv(tiny denum) ........ slowest
zmod(tiny denum) ........ slowest
zdivmod(tiny denum) ..... slowest

Note, some corresponding functions are not implemented in
some other libraries. In such cases, they have been implemented
in the translation layers (found under bench/). Those
implementations are often suboptimal, but probably in style
with what you would write if you need that functionality.
Note further, that if, for example, you want do perform
addition and you know that your operands are non-negative,
you would choose zadd_unsigned in libzahl, but if you are
using a library that does not have the corrsponding function,
you are better of with the regular addition (zadd).

Also note, TomsFastMath does not support arbitrarily large
integers, which gives is a significant performance advantage.
Furthermore, not failure check is done with GMP. Additionally,
hebimath is some functions that are not working correctly;
those have been excluded from the comparison.

Also note, NOT does not mean the same thing in all libraries,
for example in GMP it means (-x - 1), thus, znot does not
use GMP's NOT in the translations layer.
